# 史诗级更新 - 将断点组功能改造为状态机，代码清理，配置文件简化

这一份文件是 4.8-4.19 的开发日志。想看 changelog 请前往：[这里](./2024-04-19.md)

在泉城的时候尝试过，但是失败了。第一个原因是使用第三方的状态机库，导致实现变得很复杂。

读了[这篇文章](https://dev.to/davidkpiano/you-don-t-need-a-library-for-state-machines-k7h)发现，其实
不用任何库，直接用 js 对象就可以实现一个完全可以满足我们要求的状态机，而且由于没有了第三方库的约束，
代码实现上会灵活很多。

之前尝试改成状态机失败的另一原因是我想让状态机同时管理调试器的 extension.ts 和 mibase.ts，但是这是很
困难的，因为它们分属两个进程，这两个代码文件的交互是依靠 DAP 协议而不是简单的函数调用。

因此，我这次做一次减法，状态机只管理 extension.ts，任何 mibase.ts 的操作都要提到 extension.ts 来完成
。实际上这就是 DAP 设计者希望的做法，因为我们的调试器本质上是模拟用户操作，而用户操作的相关逻辑本来
就是在 extension.ts 里，而不是 mibase.ts 里实现的。

之前的想法是，断点组就是状态机，断点的数据包含在状态机里面，但是这样代码会有点复杂。我这回简化了一下
，维持原有的断点组，状态机作为断点组上层的东西，可以控制状态机。这样多了一层抽象，状态机就好写多了。
以前我的问题就是不会写这种多层抽象的代码。

我写好了状态机之后，typescript 一直报类型检查错误（原来文章里面的状态机是 js 的，类型上面比较灵活）
，于是我干脆把所有的字符串都改成 enum 了，改完发现这真是一个大好事，因为这些 enum 完美地总结了所有我
们要实现的功能：

```typescript
enum OSStates {
	kernel,
	kernel_single_step_to_user,
	user,
	user_single_step_to_kernel,
}

enum OSEvents {
	STOPPED,
	AT_KERNEL,
	AT_KERNEL_TO_USER_BORDER,
	AT_USER,
	AT_USER_TO_KERNEL_BORDER,
}

enum DebuggerActions {
	check_if_kernel_yet,
	check_if_user_yet,
	check_if_kernel_to_user_border_yet,
	check_if_user_to_kernel_border_yet,
	get_next_breakpoint_group_name,
	start_consecutive_single_steps,
	switch_breakpoint_group,
}
```

特别是 DebuggerActions。DebuggerActions 所代表的代码之前散落在各处，乱七八糟的，我自己都快看不懂了，
所以很难加新功能或做出一些修正。现在整理在一处了，接下来只要把其它文件里的有关 DebuggerActions 的代
码挪到这边，代码就会非常简洁明了。

之前还有一个想法，就是调试器的“自动单步”这类的动作采用函数来包装，然后将这些函数放到状态机里面，这样
也太复杂了。这回使用简化的思路，状态机里面将这些自动化操作表示为"actions"（这个词的来源是，我把没有
类型的 js 版本代码放到 chatgpt 里面叫它生成类型，它生成的类型定义里面有一个 Actions[]），就好像 iOS
的快捷指令一样。这种思路也更符合我们的本意。什么都是函数的函数式编成固然是好的，但是很多时候做不到
...

~~接下来我先实现 DebuggerActions ，再实现状态机和 Debugger 的交互。~~

考虑到目前的代码已经是一座巨大的 shi 山，我从最容易实现的开始。

先实现 pc 寄存器的获取。之前卡在这个地方，因为 VSCode 提供的 API 非常恶心，customRequest 发出去之后
是不能直接通过回调函数获取结果的（而且 ts 的异步我之前看了很多资料都没搞懂，问了 chatgpt 才搞懂的
。ai 的好处就是定制化的解答），一定要通过 event，但是 event 就要处理时序的问题。特别是后面要弄自动单
步，要是两个包含 pc 的 event 顺序串了就完了。

我又在 github 上搜代码，发现有人直接写`customRequest.then()`，再看了 VSCode API 文档，发现
customRequest 是可以返回 thenable 的，以前我直接忽略了这一点（因为我当时搞不懂 thenable,async,await
这些乱七八糟的），现在发现可以用上这个特性了。如果去年我就知道这个办法的话，可能能省去三分之一的折腾
时间....（不过当时好像看了文档但是没理解）

我觉得主要问题还是折腾这玩意的人太少了，所以能参考的代码不多。

蚌埠住了，mibase.ts 里的 customRequest 的返回值是 void（类型定义强制的）.....因为这个 customRequest
其实在 vscode 里面中转过一轮。

所以改变之前的计划，将状态机放到 debug adapter 中实现。实际上这反而更简单了。因为 debug adapter 里面
做过失败的状态机的尝试：

```ts
enum privilegeLevel {
	kernel,
	user,
	unknown,
	hypervisor, //not yet supported
}

class SteppingStatus {
	isStepping: boolean;
	steppingTo: privilegeLevel | null = null;
}
```

把这俩删掉，跟着报错改就行了。之前自动单步不能运转（其他同学的测试显示，会导致终端里面重新自动输入
qemu 启动命令，非常怪），是因为直接调 gdb 的 si 命令，这回改用 midebugger 里面提供的单步函数。

首先，我发现之前为了提供“停下”的信号，在四五个地方（断点触发，单步结束......）但是，稍微花点时间看一
下源代码，就会发现~~stopevent 好像包含了所有 stop 的情况。查阅 GDB 文档确认了这一点：~~ 注：后来发现
，stopEvent 确实会在每次 OS 停下来时被创建，但是我把这个跟 stopEvent 函数弄混了，stopEvent 函数只处
理一种停下来的情况，不包括因为断点而停下来的情况。

```
*stopped,reason="reason",thread-id="id",stopped-
threads="stopped",core="core"

The target has stopped. The reason field can have one of the following values:
	breakpoint-hit
		A breakpoint was reached.
	....

```

所以只要在 stopevent 一个地方设 stop 的“钩子”就行了。当然，之前会犯这个错误也怪上游代码不清晰。比如
，他们把 signal-received 命令转换成 signal-stop 字符串，所以直接在 GDB 文档里查 signal-stop 就什么都
查不出来。

状态机的初始状态是"kernel"。当停下时，改变状态。

```ts
	protected stopEvent(info: MINode) {
		this.OSStateTransition(new OSEvent(OSEvents.STOPPED));
```

`this.OSStateTransition`方法做如下的事：

1. 通过`stateTransition`查询新状态和应做的 actions
2. 更新状态`this.OSState`，执行 actions

```ts
	public OSStateTransition(event: OSEvent){
		let actions:Action[];
		[this.OSState,actions]=stateTransition(this.OSStateMachine,this.OSState,event);
		// go through the actions to determine
		// what should be done
		actions.forEach(action => this.doAction(action));
	}
```

根据状态机，`kernel` 状态时触发 `STOPPED` event . 这种情况不会改变状态（或者说状态改变到 kernel 本身
），但是会触发`check_if_kernel_to_user_border_yet` action.

```ts
				[OSEvents.STOPPED]: {
					target: OSStates.kernel,
					actions: [
						{ type: DebuggerActions.check_if_kernel_to_user_border_yet }, //if yes, event `AT_KERNEL_TO_USER_BORDER` happens
					]
				},
```

**这就是我们这个状态机的特别之处：一些 action 会导致 OSState 的变化。请特别注意。**这个特殊的情况全
部出现在`doAction`方法中：

```ts
	public doAction(action:Action){
		if(action.type === DebuggerActions.check_if_kernel_yet){
			this.miDebugger.getSomeRegisters([PROGRAM_COUNTER_ID]).then(v => {
				if(this.isKernelAddr(parseInt(v[0].valueStr,16)){
					this.OSStateTransition(new OSEvent(OSEvents.AT_KERNEL))
				}
			});
		}
		else if(action.type === DebuggerActions.check_if_user_yet){
			this.miDebugger.getSomeRegisters([PROGRAM_COUNTER_ID]).then(v => {
				if(this.isUserAddr(parseInt(v[0].valueStr,16)){
					this.OSStateTransition(new OSEvent(OSEvents.AT_USER))
				}
			});
		}
		...

	}
```

在旧版的没有状态机的代码里，这类 action 实现起来非常麻烦，比如这个`updateCurrentAddrAtStop`函数是这
么实现的：

```ts
	/// update currentAddr, currentPrivilegeLevel, privilegeLevelJustChanged
	public updateCurrentAddrAtStop(info:MINode) {
		this.currentAddr = Number(getAddrFromMINode(info));
		let newCurrentPrivilegeLevel = this.addr2privilege(this.currentAddr);

		if (newCurrentPrivilegeLevel !== this.currentPrivilegeLevel){
			this.privilegeLevelJustChanged=true;
		}else{
			this.privilegeLevelJustChanged=false;
		}
		this.currentPrivilegeLevel = newCurrentPrivilegeLevel;
	}
```

需要同时更新`currentAddr, currentPrivilegeLevel, privilegeLevelJustChanged`。这样的代码非常难维护，
我到现在都不知道这段代码和它相关的那些代码到底是哪里出错了 =\_=

由于有了状态机`OSStateMachine`和状态机的转换方法`OSStateTransition`，我们不需要手动更新特权级和“特权
级刚刚变过”的 flag 了。我们只需要获取 PC 寄存器，判断它的区间，如果是所需区间，激活“到达 xx 特权级”
的事件即可，简单多了。

过去是在断点触发的时候判断这个断点是不是边界，现在由于状态机的表述方式不同，改为需要判断“我在哪里”时
，发送一个单独的 GDB 命令来获得这个信息。

在 google 上找到 gdb 命令（`where`），查找文档得到对应的 MI 命令（`-stack-list-frames`），查找代码发
现插件已经有了一个得封装很好的实现了（`getStack`），因此不需要像之前那样用硬编码的方式从 MINode 里获
取数据了。太好了。

这个`stack`的`stack frame`指的是函数的调用栈，和页帧无关。我们只要取最上一层的 frame 0 即可。

```ts
		else if(action.type === DebuggerActions.check_if_kernel_to_user_border_yet){
			let filepath:string = "";
			let lineNumber:number=-1;
			//todo if you are trying to do multi-core debugging, you might need to modify the 3rd argument.
			this.miDebugger.getStack(0,1,this.recentStopThreadID).then(v=>{
				filepath=v[0].file;
				lineNumber=v[0].line;
			});
			if (filepath===this.kernel_to_user_border_filename && lineNumber===this.kernel_to_user_border_line){
				this.OSStateTransition(new OSEvent(OSEvents.AT_KERNEL_TO_USER_BORDER));
			}
		}
```

然而，由于状态机比较简陋，这种实现还是有不完美的地方。

1. 一些行为没有放到状态机里面（但是全部都在`doAction`方法里）
2. 依赖`recentStopThreadID`. 这个数据是在状态机之外的`StopEvent`方法里更新的。

但是比之前还是好了无数倍。而且我听取了杨金博的建议，把之前全大写且令人（包括我自己）困惑
的`KERNEL_OUT_BREAKPOINTS_LINE`改成了`kernel_to_user_border_line`。

发现一个技巧，以前我写代码是自底向上的，比如这边`kernel_to_user_border_line`还没实现，我就会去实现这
个变量。但是这样经常会把自己绕进去，所以不如这里就先不实现，先把大体的最核心的代码实现了。反正没实现
的细枝末节，IDE 都会报错，最后再来写就行。

还有一个技巧，就算代码没写完，编译报错，其实也是可以编译通过的（点“仍要调试”），这样可以在代码没写完
的情况下测试一些功能。

关于怎么获取下一个要执行的进程，我问了杨金博，它给的方法是这样的：

1. 执行到内核的时候，根据系统调用号检测
2. 给内核的系统调用处理程序添加断点，进入到这里的时候就检测是什么系统调用。 2.1 如果是 exec 等可能改
   变内核运行程序的，就记录一下
3. 如果内核处理进程 b 的 syscall 的中途调度到了进程 a，然后返回用户态时执行进程 a，这种情况使用页表
   地址辅助判断（因为一个线程只会对应一个页表，并且页表是在寄存器里的）

这个办法是比较完善的，但是需要每个 OS 都进行适配，我觉得都可以拿去参加下一届 OS 比赛了。我先实现我们
目前已经做到的部分，即在 exec 系统调用获取下一个进程名，先不管 syscall 处理一半然后调度到其他地方的
情况。

之前，我由于时间有限，采取了粗糙的方式来解析 MINode（正则表达式）。现在我们应该使用 mi2.ts 里面那些
封装好的函数。

还有一个问题是断点组名字和进程名的对应的问题。目前先采用简单的办法：用 linux 命令行工具找到最接近的
搜索结果。

这些问题都想明白后，开始写代码。首先定义一个默认的用户态程序名作为“兜底”。这个默认的用户程序名由用户
传入。

```ts
class AddressSpaces {
	protected nextBreakpointGroup:string;

```

其次，定义一个“钩子”（我自己乱起的名字）：

```ts
// use this to get next process name
class KernelHookBreakpoint {
	breakpoint: Breakpoint;
	//environment:Variable[];
	behavior: Function;
}
```

当停下时，STOPPED 事件发生，根据状态机，会触发`try_get_next_breakpoint_group_name` action. 这个
action 的作用是，判断当前是否停在了 KernelHookBreakpoint.breakpoint 上了。如果是的话，调用 behavior
做信息收集的工作。~~收集到的信息放在 environment 里面~~。

其实跟 ebpf 的用法有点像。

发现 environment 根本没用，直接调用 behavior 把结果返回即可。这里还要解决一个问题，就是用户怎么把函
数传进来。网上有这个办法，利用 Function 构造函数：

```ts
//JSON: {"function":{"arguments":"a,b,c","body":"return a*b+c;"}}

var f = new Function(function.arguments, function.body);

```

但是这就要求用户掌握我们`mibase.ts`里面的 API。我的打算是提供一组简单的包装好的函数给用户使用。不过
这个可以后边再说。

这种设计的可扩展性很强，比较通用，以后其他同学要想完善断点组切换功能的话，只需要定义新的 behavior 和
environment 就可以。

> 这时候我发现 js 的闭包真的很好用。Closures are functions which remember the environment they were
> created in.
> https://stackoverflow.com/questions/42920563/are-execution-context-and-closure-the-same-thing-in-javascript

至此，状态机功能的基本骨架就完成了。

根据我们现在的状态机，边界断点应该包含在断点组里面。所以像之前那样发一个 customRequest，让 GDB 直接
设断点（不经过 mibase.ts 的 setBreakPointsRequest，因此不会保存到断点组里面）就不合适了。我当时刚好
在删 extension.ts 里的不用的代码，发现 GoToKernel 等几个按钮可以移除了，因为它们的功能要么是不必要的
，要么就是已经通过新的状态机自动化地实现了。我突然想到，能不能像之前弄 eBPF 的图形界面时候一样，添加
一个右键菜单，用户在某个断点上面右键单击即可将这个断点变成边界断点。

这么做的理由：

1. 根据上回实现 eBPF 右键菜单的经验来看，实现难度很低
2. 之前是因为对这个插件的断点相关的数据结构不熟悉，对 ts 也不熟悉。所以才跳过 Debug Adapter 直接输入
   GDB 命令的。去泉城之后我从杨佬那边学了一些工程上的技巧，对一些以前的疑惑也解答了，而且对插件里这
   些数据结构逐渐熟悉了，在 Breakpoint 里面加一个 isBorderBreakpoint 的可选数据应该很简单。
3. GDB 设断点会有一个断点偏移的问题，比如说你设置在 12 行，GDB 可能会把断点改到 15 行进行设置。之前
   把边界断点信息都放在配置文件里面时，就需要反复尝试来找到断点不会偏移的行。如果改为用右键菜单设置
   边界断点，肯定是用户先设断点，断点偏移，然后用户再将偏移后的那个断点设为边界断点，就没这个问题。
4. 调试器的用户肯定会反复改动 os 代码，因此边界断点的行号肯定会一直变。不仅要改配置文件还要考虑断点
   偏移，很麻烦。如果开始 debug 再用鼠标点反而更自然。断点组机制的实现也会更自然。比如，每个用户程序
   的出口断点可能不一样（比如，一些是 rust 程序，一些是 C 的），用户可以选择刚开始 debug 的时候并不
   指定所有边界断点，而是运行到了用户态再添加用户断点。比静态的配置文件要好的多。
5. 我们最早的时候其实就想这么做的。只不过当时（2022 年）没有关于编辑器上行号那一列的 API。这个 API
   是 2023 年 4 月才更新的。

stackOverflow 上有人试图做类似的事：
<https://stackoverflow.com/questions/69871718/is-there-an-api-to-add-an-item-to-the-gutters-context-menu>

这个 API 的使用例子（官方文档不给，找了半天
）<https://github.com/ulugbekna/new-extension/blob/editor-lineNumber-context/src/extension.ts>

我发现先设置断点，再改为边界断点会有点麻烦，因为在 VSCode API 中，通过右键菜单可以获得的是行号和文件
名或 uri.然后我得根据这些信息反找回存储在 Debug Adapter 和断点组里的断点信息，更麻烦。不如直接弄一个
“设边界断点”的菜单得了。断点偏移的问题 VSCode 会自动处理。~~**但是经过一番搜寻后，发现 VSCode 仍然没
有提供在文本编辑器界面设置断点的功能**，所以仍然只能先设置普通断点，再将它改为边界断点。~~ 经过一番
查找，我发现 VSCode 提供了在文本编辑器界面设置断点，以及将这个断点同步到 Debug Adapter 的功能。但是
没有提供修改现有断点属性的功能，**因此我们只能直接设置边界断点**。

之前提到的断点组名字和断点文件名的对应的问题，应该这么解决：~~VSCode 设置断点后，Debug Adapter 会根
据 VSCode 提供的文件名和行号设断点。设完断点后 GDB 会返回改动的文件名（类似于去掉/home/之类的怪异行
为）和改动的行号（因为有断点偏移的问题）。我们记录下改动的文件名和改动的行号，之后不论是断点组还是其
他什么地方全部用这个信息。~~ 解决办法非常简单：**所有地方都用完整的文件路径**即可。之前我会把断点组
名字设置为文件名本身。

组会和吴老师交流过，他反对这个改动，我打算实现完这个功能，代码都清理干净后，再把配置文件的配置功能加
回来。

这回微软提供了足够多的 API 来实现我们的功能了。注意 Breakpoint 的构造方法是 protected 的，它的目的是
不让开发者直接创建新的 Breakpoint 实例，而是继承 Breakpoint 方法。但是，我发现插件的代码里面居然有三
个 Breakpoint 类:vscode.Breakpoint, DAP 的 breakpoint，DAP 后端（mi2.ts）的 breakpoint.为了添加一个
属性要改三个类，而且前两个类还改不了。所以我放弃了直接把 isBorder 属性加到 Breakpoint 类的想法
，isBorder 这个属性还是交给断点组管理模块去管理。因此，我在 Debug Adapter 层面是先设置断点，再给断点
添加“边界”属性的。（在 VSCode 的层面则不是）

```ts
		vscode.debug.addBreakpoints([breakpoint]);//this will go through setBreakPointsRequest in mibase.ts
		vscode.debug.activeDebugSession?.customRequest('setBreakpointAsBorder',args[0]);
	});


```

~~我现在掌握了 ts 的回调函数和 for of，因此我顺便润色了一下断点组切换的代码。~~没什么地方好润色的

~~这个 customRequest 还没实现。先睡觉了。~~ 这个 customRequest 改为 setBreakpointAsBorder 实现了，见
下文。

昨晚代码写着写着发现自己需要实现“地址转断点组”的功能了。这个功能经过无数次实验证明必须由用户自己提供
。好在我们现在已经知道怎么用 Function 构造函数了。这么看来我们的调试器还是很复杂的，好在现在代码已经
基本厘清了。现在新写的代码的抽象层次会搞一些，所以思考的负担减轻了。

看了一下 mi2.ts 的代码，我觉得把断点组和 Debug Adapter 本身的断点管理功能合为一体不是好事，因为
Debug Adapter 会对这些断点做很多的操作，怕会造成更多麻烦。我之前在断点组里面直接存
SetBreakpointArguments，而不是 BreakpointGroupBrks 之类的玩意，这个策略没有任何的问题，因为断点组管
理模块的作用就是在合适的时机进行断点设置，而非存储某个断点。而且 SetBreakpointArguments 里面已经包含
了断点所需要的所有信息。只不过，这回我们可能要继承 SetBreakpointArguments，添加一个 isBorder 属性。
然后通过 customRequest 对这个 isBorder 属性做更改。对于怎么找到某个 SetBreakpointArguments，暴力查找
已经是风险最低的办法。唯一的优化措施是先通过用户提交的地址转断点组函数，找到断点组，再在断点组里面暴
力查找。但是用户总共也设置不了多少断点，这么做没太大意义。

这里遇到了一个问题，断点是可以取消的，然而取消断点并没有使用 mi2.ts 里的 removeBreakpoint 函数，而是
把那一个文件的断点全部删除，然后重新设置。这种情况如果发生的话断点组还要做信息的同步，很麻烦，再加上
断点偏移的问题我真的不知道怎么解决。

因此我想到了一种新方案：回到“设置断点-断点偏移-用户把偏移后的断点设置为边界”的方案，这样就不用解决断
点偏移的问题。同时，边界的信息并不存储在断点的数据结构里，而是存在断点组的数据结构里，这样就不用去查
找到某个断点的数据结构，再将它改为“边界”。这样做还有一个好处，无需改动原有的断点数据结构（因为边界的
信息不再存储在断点的数据结构中，而是存在断点组的属性中）。用这种思路的话，顺便再增加一个“去除本地址
空间的边界断点”功能，就同时实现了边界断点的更改。至于把边界断点改回普通断点的功能就没有必要了。

我觉得这个方案堪称完美。因为两年前写断点组切换的代码时，除了完全清空所有断点组信息
（removeallclibreakpoint）的情况外，断点组本身是不会被删除的（断点组里面的断点可能会被删除）。因此我
们把边界的信息附加在断点组上，做到了和之前代码的兼容，因此代码量小，现有的断点组切换的代码完全不需要
更改。

```ts


	//There is only 1 border per breakpoint group. So it you set border twice in a breakpoint group, the newer one will replace the older one.
	const setBreakpointAsBorderCmd = vscode.commands.registerCommand('code-debug.setBreakpointAsBorder', (...args) => {
		const uri = args[0].uri;
		const fullpath = args[0].uri.fsPath; // fsPath provides the path in the form appropriate for the os.
		const lineNumber = args[0].lineNumber;
		// we set the line index to 0 since currently we don't want to deal with positions in a line
		let breakpoint = new vscode.SourceBreakpoint(new vscode.Location(uri,new vscode.Position(lineNumber,0)),true);
		vscode.debug.addBreakpoints([breakpoint]);//this will go through setBreakPointsRequest in mibase.ts
		vscode.debug.activeDebugSession?.customRequest('setBorder',new Border(fullpath,lineNumber));
	});

	//customRequest=======

				case 'setBorder':
				let border:Border = args;
				this.addressSpaces.updateBorder(border);
				break;

	//====================


	public updateBorder(border: Border) {
		let spaceNameOfBorder:string = this.debugSession.filePathToSpaceName(border.filepath);
		let flag = false;
		for(let space of this.spaces){
			if(space.name===spaceNameOfBorder){
				flag=true;
				space.border=border;
			}
		}
		if(flag===false){
			this.spaces.push(new AddressSpace(spaceNameOfBorder,[],border));
		}
	}



```

其中`filePathToSpaceName`函数是由用户在 launch.json 中提供的，因为 filepath=>SpaceName 的逻辑每个 OS
都不一样。

除此之外我们再写一个把边界断点改回普通断点的功能，虽然在前面几段我说没必要，但是我突然发现这个功能其
实非常好实现:

```ts

	const removeBorderOfThisBreakpointGroupCmd = vscode.commands.registerCommand('code-debug.removeBorderOfThisBreakpointGroup', (...args) => {
		const uri = args[0].uri;
		const fullpath = args[0].uri.fsPath; // fsPath provides the path in the form appropriate for the os.
		const lineNumber = args[0].lineNumber;
		vscode.debug.activeDebugSession?.customRequest('removeBorder',fullpath);
	});

	//customRequest=========

				case 'removeBorder':
				let filepath:string=args;
				this.addressSpaces.removeBorder(filepath);
				break;

	//=====================


	public removeBorder(filepath: string) {
		let spaceNameOfBorder:string = this.debugSession.filePathToSpaceName(filepath);
		let flag = false;
		for(let space of this.spaces){
			if(space.name===spaceNameOfBorder){
				flag=true;
				space.border=undefined;
			}
		}
		if(flag===false){
			//do nothing
		}
	}
```

突然想到要是没给边界怎么办。看了下代码，没给边界的话就不会切换断点组，就在当前断点组一直运行下去。也
没啥问题。

现在写最后一块比较主要的代码：符号表文件的切换。符号表文件和断点组在 rCore-Tutorial-v3 里是一对一的
，但是其他 OS 就不能保证了。而且，rCore-Tutorial-v3 的内核和用户符号表有时可以共存，有时不行，不知道
在其他 OS 上又是什么怪样子。因此符号表文件随着断点组切换而切换的逻辑作为用户提交代码。

发现之前是 添加新符号表-移除旧断点-打新断点 根本没有去除符号表。之前内核的符号表是不删去的。这样其实
不完善。 由于断点是依赖符号表的，合理的顺序应该是 移除旧断点-移除旧符号表-添加新符号表-添加新断点。
如果是这个顺序的话，符号表切换的逻辑就得放在 断点组切换 的函数里面，不能单列一个函数了。因此我们不能
把整个符号表切换的逻辑抽离出来作为用户自定义代码。我们只能将 断点组=>符号表文件路径 的映射作为自定义
代码。

之前 addDebugSymbol 和 removeDebugSymbol 是直接在 mibase.ts 里调用 sendCliCommand，这回严谨一些，放
到 mi2.ts 里：

```ts
	addSymbolFile(filepath:string): Thenable<any> {
		if (trace) this.log("stderr", "addSymbolFile");
		return new Promise((resolve, reject) => {
			const promises: Thenable<void | MINode>[] = [];
			promises.push(
				this.sendCliCommand("add-symbol-file " + filepath).then((result) => {
					if (result.resultRecords.resultClass == "done") resolve(true);
					else resolve(false);
				})
			);
			Promise.all(promises).then(resolve, reject);
		});
	}

	removeSymbolFile(filepath:string): Thenable<any> {
		if (trace) this.log("stderr", "removeSymbolFile");
		return new Promise((resolve, reject) => {
			const promises: Thenable<void | MINode>[] = [];
			promises.push(
				this.sendCliCommand("remove-symbol-file " + filepath).then((result) => {
					if (result.resultRecords.resultClass == "done") resolve(true);
					else resolve(false);
				})
			);
			Promise.all(promises).then(resolve, reject);
		});
	}


```

断点组切换时，符号表也切换：

```ts
//功能和disableCurrentSpaceBreakpoints有重合。
	//断点被触发时会调用该函数。如果空间发生变化（如kernel=>'src/bin/initproc.rs'）
	//缓存旧空间的断点，令GDB清除旧断点组的断点，卸载旧断点组的符号表文件，加载新断点组的符号表文件，加载新断点组的断点
	public updateCurrentSpace(updateTo: string) {
		let newIndex = -1;
		for (let i = 0; i < this.spaces.length; i++) {
			if (this.spaces[i].name === updateTo) {
				newIndex = i;
			}
		}
		if (newIndex === -1) {
			this.spaces.push(new AddressSpace(updateTo, []));
			newIndex = this.spaces.length - 1;
		}
		let oldIndex = -1;
		for (let j = 0; j < this.spaces.length; j++) {
			if (this.spaces[j].name === this.currentSpaceName) {
				oldIndex = j;
			}
		}
		if (oldIndex === -1) {
			this.spaces.push(new AddressSpace(this.currentSpaceName, []));
			oldIndex = this.spaces.length - 1;
		}
		this.spaces[oldIndex].setBreakpointsArguments.forEach((e) => {
			this.debugSession.miDebugger.clearBreakPoints(e.source.path);
		});

		this.debugSession.miDebugger.removeSymbolFile(this.debugSession.SpaceNameToDebugFilePath(this.getCurrentSpaceName()));

		this.debugSession.miDebugger.addSymbolFile(this.debugSession.SpaceNameToDebugFilePath(this.spaces[newIndex].name));

		this.spaces[newIndex].setBreakpointsArguments.forEach((args) => {
			this.debugSession.miDebugger.clearBreakPoints(args.source.path).then(
				() => {
					let path = args.source.path;
					if (this.debugSession.isSSH) {
						// convert local path to ssh path
						path = this.debugSession.sourceFileMap.toRemotePath(path);
					}
					const all = args.breakpoints.map((brk) => {
						return this.debugSession.miDebugger.addBreakPoint({
							file: path,
							line: brk.line,
							condition: brk.condition,
							countCondition: brk.hitCondition,
						});
					});
				},
				(msg) => {
					//TODO
				}
			);
		});
		this.currentSpaceName = this.spaces[newIndex].name;


	}

```

看了一下状态机，发现有一个漏洞。因为 文件名 => 断点组名 的函数改由用户提供，所以内核断点组不一定叫
"kernel"，所以在用户态的时候也要获取下一个断点组。但是用户态程序肯定是回到内核的，而且**由于用户态程
序都是有隔离性的，大概也获取不到下一个断点组要去哪里**。所以我们假设用户态程序只会回到内核，不会跑到
其它地方去。依照这个逻辑，应该在由内核断点组转为用户态断点组的时候，就将“下一断点组”设置为内核的断点
组的名字。

**如果未来要加入 hypervisor 的跟踪的话也是类似**。由于执行环境的隔离性，底层可以知道接下来要去哪个顶
层的断点组，但是反过来不行。解决办法是，**底层转到高层时，就预先假设高层会回到这个底层。在高层运行期
间不去获取接下来要回到哪个底层，因为根本获取不到**。

所以，`switch_breakpoint_group` 变为 `high_level_switch_breakpoint_group_to_low_level` 和
`low_level_switch_breakpoint_group_to_high_level`。

内核转换到用户态时用`low_level_switch_breakpoint_group_to_high_level`，包含了指
定`nextbreakpointgroup`为内核的行为；而用户态切换回内核时用
的`high_level_switch_breakpoint_group_to_low_level`则没有：

```ts
		else if(action.type === DebuggerActions.high_level_switch_breakpoint_group_to_low_level){//for example, user to kernel
			this.addressSpaces.updateCurrentSpace(this.addressSpaces.getNextBreakpointGroup());
		}
		else if(action.type === DebuggerActions.low_level_switch_breakpoint_group_to_high_level){//for example, kernel to user
			this.addressSpaces.updateCurrentSpace(this.addressSpaces.getNextBreakpointGroup());//注：这一行已经更新过currentSpaceName，会导致下一行setNextBreakpointGroup设置错误的下一断点组！后文我改回去了
			this.addressSpaces.setNextBreakpointGroup(this.addressSpaces.getCurrentSpaceName());
		}
```

状态机也改了。内核转换到用户态时用`low_level_switch_breakpoint_group_to_high_level`，而用户态切换回
内核时用`high_level_switch_breakpoint_group_to_low_level`：

```ts
export const OSStateMachine: OSStateMachine = {
	initial: OSStates.kernel,
	states: {
		[OSStates.kernel]: {
			on: {
				[OSEvents.STOPPED]: {
					target: OSStates.kernel,
					actions: [
						{ type: DebuggerActions.try_get_next_breakpoint_group_name }, //if got, save it to a variable. if not, stay the same. initial is "initproc"
						{ type: DebuggerActions.check_if_kernel_to_user_border_yet }, //if yes, event `AT_KERNEL_TO_USER_BORDER` happens
					],
				},
				[OSEvents.AT_KERNEL_TO_USER_BORDER]: {
					target: OSStates.kernel_single_step_to_user,
					actions: [{ type: DebuggerActions.start_consecutive_single_steps }],
				},
			},
		},
		[OSStates.kernel_single_step_to_user]: {
			on: {
				[OSEvents.STOPPED]: {
					target: OSStates.kernel_single_step_to_user,
					actions: [
						{ type: DebuggerActions.check_if_user_yet }, //if yes, event `AT_USER` happens. if no, keep single stepping
					],
				},
				[OSEvents.AT_USER]: {
					target: OSStates.user,
					actions: [
						// border breakpoint is included in breakpoint group.
						// also switch debug symbol file
						// after breakpoint group changed, set the next breakpoint group to the kernel's breakpoint group.
						{ type: DebuggerActions.low_level_switch_breakpoint_group_to_high_level },
					],
				},
			},
		},
		[OSStates.user]: {
			on: {
				[OSEvents.STOPPED]: {
					target: OSStates.user,
					actions: [
						{ type: DebuggerActions.check_if_user_to_kernel_border_yet }, //if yes, event `AT_USER_TO_KERNEL_BORDER` happens
					],
				},
				[OSEvents.AT_USER_TO_KERNEL_BORDER]: {
					target: OSStates.user_single_step_to_kernel,
					actions: [
						{ type: DebuggerActions.start_consecutive_single_steps }, // no need to `get_next_breakpoint_group_name` because the breakpoint group is already set when kernel changed to user breakpoint group
					],
				},
			},
		},
		[OSStates.user_single_step_to_kernel]: {
			on: {
				[OSEvents.STOPPED]: {
					target: OSStates.user_single_step_to_kernel,
					actions: [
						{ type: DebuggerActions.check_if_kernel_yet }, //if yes, event `AT_KERNEL` happens. if no, keep single stepping
					],
				},
				[OSEvents.AT_KERNEL]: {
					target: OSStates.kernel,
					actions: [
						{ type: DebuggerActions.high_level_switch_breakpoint_group_to_low_level }, // including the border breakpoint
					],
				},
			},
		},
	},
};
```

现在基本的功能全部实现了，做一下 launch.json 内的配置信息到 mibase.ts 里的变量 的映射，然后编写一下
两个用户提供的函数，和内核钩子。

终于所有的报错都清了，插件能编译，但运行的时候报错了。报错的行号要去 out 文件夹里（ts 转移成 js 后的
文件）查看。原来自己 launch.json 还没写。看来要加一个配置文件完整性的检查。之前只检查了 qemu 的两个
参数。

发现只要更改 package.json 就可以进行配置完整性的检查，顺便也把之前 launch.json 里面乱报错的问题解决
了。

在实现`filePathToSpaceName`和`spaceNameToDebugFilePath`的时候，我发现了`filePathToSpaceName`在使用后
是需要做失败处理的，因为用户态程序运行到用户库的时候，由于所有应用程序都共享同一份用户库代码，~~这种
情况下是无法通过用户库的断点的文件名得知断点组名的。目前解决办法是，获取不到的话只需要认为断点组保持
不变即可，因为只有用户态程序会出现上述这在情况，内核是不会出现这种情况的（不考虑将来跟踪 hypervisor
的话）~~ **这种情况下并不是无法获知断点组名，而是一个断点会同时属于多个断点组**。比如
rCore-Tutorial-v3 里 user/src/syscall.rs 里的断点就属于所有用户态程序的断点组。

`spaceNameToDebugFilePath`不会有这个问题。

所以我这样写`filePathToSpaceName`函数：

```ts
if (filePathStr.includes("os/src")) {
	return ["kernel"];
} else if (filePathStr.includes("user/src/bin")) {
	return [filePathStr];
} else if (!filePathStr.includes("user/src/bin") && filePathStr.includes("user/src")) {
	return [
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/adder_atomic.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/adder_mutex_blocking.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/adder_mutex_spin.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/adder_peterson_spin.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/adder_peterson_yield.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/adder.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/adder_simple_spin.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/adder_simple_yield.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/barrier_condvar.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/barrier_fail.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/cat.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/cmdline_args.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/condsync_condvar.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/condsync_sem.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/count_lines.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/eisenberg.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/exit.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/fantastic_text.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/filetest_simple.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/forktest2.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/forktest.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/forktest_simple.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/forktree.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/gui_rect.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/gui_simple.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/gui_snake.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/gui_uart.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/hello_world.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/huge_write_mt.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/huge_write.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/infloop.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/initproc.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/inputdev_event.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/matrix.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/mpsc_sem.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/peterson.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/phil_din_mutex.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/pipe_large_test.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/pipetest.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/priv_csr.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/priv_inst.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/race_adder_arg.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/random_num.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/run_pipe_test.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/sleep.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/sleep_simple.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/stackful_coroutine.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/stackless_coroutine.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/stack_overflow.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/store_fault.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/sync_sem.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/tcp_simplehttp.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/threads_arg.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/threads.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/udp.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/until_timeout.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/user_shell.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/usertests.rs",
		"/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/yield.rs",
	];
} else return ["kernel"];
```

注意，如果确实找不到断点空间（比如一些在 GDB 里面开头是/rust 的库文件），就把它归为内核的断点。

我把用到`filePathToSpaceNames`的地方都改成能够处理一个断点对应多个断点组的情况了。改
setBreakPointsRequest 的时候比较累，因为一个断点属于多个断点组，多个断点组中有一个是当前断点组，就允
许 GDB 设置断点，我总觉得这个机制是不是有什么漏洞，当然实际上没有，因为我们一开始就把断点信息存到所
有断点组里面了。如果删除这种“一对多”的断点的话也不用担心（感谢微软这个看上去很莫名其妙的 API），因为
并不存在删除断点的动作，而是 args 参数传来那个文件对应的所有断点，然后那一个文件对应的所有断点都被清
掉，全部重新设置一遍。断点组管理模块也是这样的。

```ts
	/// 用于设置某一个文件的所有断点
	protected override setBreakPointsRequest(response: DebugProtocol.SetBreakpointsResponse, args: DebugProtocol.SetBreakpointsArguments): void {
		// the path is supposed to be FULL PATH like /home/czy/project/file.c
		let path = args.source.path;
		if (this.isSSH) {
			// convert local path to ssh path
			path = this.sourceFileMap.toRemotePath(path);
		}
		//先清空该文件内的断点，再重新设置所有断点
		this.miDebugger.clearBreakPoints(path).then(() => {
			let spaceNames:string[] = this.filePathToSpaceNames(path);
			let currentSpaceName = this.addressSpaces.getCurrentSpaceName();
			//保存这些断点信息到断点所属的断点组（可能不止一个）里
			for(let spaceName in spaceNames){
				this.addressSpaces.saveBreakpointsToSpace(args, spaceName);
			}
			//注意，此时断点组管理模块里已经有完整的断点相关的信息了

			let flag = false;
			for(let spaceName in spaceNames){
				if(spaceName===currentSpaceName) { flag = true; }
			}
			//如果这些断点所属的断点组和当前断点组没有交集，比如还在内核态时就设置用户态的断点，就结束函数，不通知GDB设置断点
			if(flag===true) return;

			//反之，如果这些断点所属的断点组中有一个就是当前断点组，那么就通知GDB立即设置断点
			const all = args.breakpoints.map(brk => {
				return this.miDebugger.addBreakPoint({ file: path, line: brk.line, condition: brk.condition, countCondition: brk.hitCondition });
			});
			//令GDB设置断点
			Promise.all(all).then(brkpoints => {
				const finalBrks: DebugProtocol.Breakpoint[] = [];
				brkpoints.forEach(brkp => {
					// TODO: Currently all breakpoints returned are marked as verified,
					// which leads to verified breakpoints on a broken lldb.
					if (brkp[0])
						finalBrks.push(new DebugAdapter.Breakpoint(true, brkp[1].line));
						});
						response.body = {
							breakpoints: finalBrks,
						};
						this.sendResponse(response);
					},
					(msg) => {
						this.sendErrorResponse(response, 9, msg.toString());
					}
				);
			},
			(msg) => {
				this.sendErrorResponse(response, 9, msg.toString());
			}
		);
	}

```

我突然想到同样一行库代码在不同 debug file 里面的地址可能是不一样的，不过这个不影响，因为我们的断点是
到了那个地址空间才设置的，而且设置的时候依靠的是文件名和行号。文件名和行号不会因为断点组变化而变化。

尝试运行了一下，出现了很多诡异的现象。比如`setBreakpointAsBorder`会多设置断点，因为多加了一个设置断
点的语句。然后就是单步功能不起作用。最头痛的是，用户传进去的那些函数根本就不起作用。

好好好，查了整整半天，发现是因为我的 function 数据结构多家了一层没注意：

```json
{ "function": { "functionArguments": "groupName", "functionBody": ".........." } }
```

第一层有个 function，我忘了，无语=\_= 不过，刚才查资料注意到，**Function 构造函数生成的函数是没有闭
包特性的，它只能访问它的参数以及全局变量。**，等会实现获取变量的功能的时候要注意。

然后继续排查为什么没有单步的时候，发现又是粗心了，好好好，把 stoppedEvent 和 stopEvent 函数弄混了。
不过这个好解决。搜索 new StoppedEvent ，找到四行语句，然后在这四行的下方加一个状态机的 stopped 事件
更新和 thread id 的更新即可。

```ts

	protected handleBreak(info?: MINode) {
		const event = new StoppedEvent("step", info ? parseInt(info.record("thread-id")) : 1);
		(event as DebugProtocol.StoppedEvent).body.allThreadsStopped = info
			? info.record("stopped-threads") == "all"
			: true;
		this.sendEvent(event);
		this.OSStateTransition(new OSEvent(OSEvents.STOPPED));
		this.recentStopThreadID = parseInt(info.record("thread-id"));
	}

```

这个问题解决后，单步还是不行，发现是因为，调试器在启动之前也会有一些 stopevent。此时会调用

```ts
this.miDebugger.getStack(0, 1, this.recentStopThreadID).then((v) => {
	filepath = v[0].file;
	lineNumber = v[0].line;
});
```

造成崩溃（因为此时 OS 根本没运行起来）。注意到

```ts
this.miDebugger.once("debug-ready", () => this.sendEvent(new InitializedEvent()));
```

改为：

```ts
this.miDebugger.once("debug-ready", () => {
	this.OSDebugReady = true;
	this.sendEvent(new InitializedEvent());
});
```

然后，四个 stoppedEvent 都确保 OSDebugReady===true 的情况下才进行事件的激发。这样就不会崩溃了。

然而又有新问题，断点设置了但是没激活。这个情况下要看一下断点组。

发现断点组里面有一个叫`"0"`的，离谱.

我把这两句话的顺序调换成这样，就不会“跑飞”（调试自动终止）了，因为调换之后 recentStopThreadID 就不可
能是 undefined：

```ts
if (this.OSDebugReady) {
	this.recentStopThreadID = parseInt(info.record("thread-id"));
	this.OSStateTransition(new OSEvent(OSEvents.STOPPED));
}
```

但是`"0"`的问题还没解决。蚌埠住了，查了两个小时 bug 发现是 of 写成 in 了：

```ts
for (let spaceName in spaceNames) {
	this.showInformationMessage("mibase.ts line 605 spaceName " + spaceName);
	this.addressSpaces.saveBreakpointsToSpace(args, spaceName);
}
```

for in 遍历数组的话遍历的是下标而不是数组元素

发现犯了一个错误。发生错误的这个场景其实之前想过，但是并没去深究：

```ts
//错误代码示例
let filepath: string = "";
let lineNumber: number = -1;
let kernelToUserBorderFile = this.addressSpaces.getCurrentSpace().border.filepath;
let kernelToUserBorderLine = this.addressSpaces.getCurrentSpace().border.line;
//todo if you are trying to do multi-core debugging, you might need to modify the 3rd argument.
// 这个函数是非阻塞的，所以下面的filePath仍然保持原始的值""
this.miDebugger.getStack(0, 1, this.recentStopThreadID).then((v) => {
	this.showInformationMessage("v is " + JSON.stringify(v));
	filepath = v[0].file;
	lineNumber = v[0].line;
});
// 上方的函数是非阻塞的，所以下面的filePath仍然保持原始的值""
if (filepath === kernelToUserBorderFile && lineNumber === kernelToUserBorderLine) {
	this.OSStateTransition(new OSEvent(OSEvents.AT_KERNEL_TO_USER_BORDER));
}

//正确写法
let filepath: string = "";
let lineNumber: number = -1;
let kernelToUserBorderFile = this.addressSpaces.getCurrentSpace().border.filepath;
let kernelToUserBorderLine = this.addressSpaces.getCurrentSpace().border.line;
//todo if you are trying to do multi-core debugging, you might need to modify the 3rd argument.
this.miDebugger.getStack(0, 1, this.recentStopThreadID).then((v) => {
	this.showInformationMessage("v is " + JSON.stringify(v));
	filepath = v[0].file;
	lineNumber = v[0].line;
	if (filepath === kernelToUserBorderFile && lineNumber === kernelToUserBorderLine) {
		this.OSStateTransition(new OSEvent(OSEvents.AT_KERNEL_TO_USER_BORDER));
	}
});
```

终于！！！开始有点不一样的反应了，显示开始自动单步了，而且还成功单步了几十次，到了用户态！！！！！！
但是还是跑飞了。

可能是因为没有成功去除内核态符号表。查了下发现 remove-symbol-file 只能移除通过 add-symbol-file 加入
的符号表，而我们的内核符号表是用 file-symbol-file 加入的。这简单，只要改一下配置文件，让 GDB 在启动
的时候通过 add-symbol-file 再加载一次符号表即可。

这样可以，我们成功进到用户态，而且可以进行单步。但是 remove-symbol-file 是否有把通过
file-symbol-file 加载的符号表文件卸载掉？这个查了下资料，发现确实无从得知。所以我改了
launch.json，executable 选项留空，autorun 选项里面用 add-debug-file 加载内核符号表，这样就 ok 了
。**这样改完之后，第一次尝试时其实跑飞了，但是多尝试几次又正常了**.....有问题的话以后再改回去。

发现以下这份测试代码是跑得通的，所以虽然 Function 创建的函数可能会有闭包上的问题，但是访问 this 是完
全 ok 的，可以直接调用 this.xxx().

```ts
class myclass {
	private a: number;
	public myfunc: Function;
	constructor(a: number, myfunc: Function) {
		this.a = a;
		this.myfunc = myfunc;
	}
}

let myObj = new myclass(1, new Function("num", "this.a++;return this.a+num"));

console.log(myObj.myfunc(3));
```

用户态没有回到内核态的原因也找到了，也是上文提到的.then()函数还没执行完就获取该函数会修改的值，导致
值是初省值。完全同样的问题。

再测试了一下，用户态也可以回到内核了！但是断点组和符号表都切换错了（本应该切换到内核，实际上却切回
initproc 了），排查之后发现这两行写错了，当时写的时候更新数据的顺序没弄清楚。updateCurrentSpace 函数
会把 currentSpaceName 改掉的：

```ts
//正确版本
			let low_level_breakpoint_group_name = this.addressSpaces.getCurrentSpaceName();
			let high_level_breakpoint_group_name = this.addressSpaces.getNextBreakpointGroup();
			this.addressSpaces.updateCurrentSpace(high_level_breakpoint_group_name);
			this.addressSpaces.setNextBreakpointGroup(low_level_breakpoint_group_name);
		}
```

此外 try_get_next_breakpoint_group_name 的处理逻辑里面也有同样的.then()函数还没执行完就获取该函数会
修改的值，导致值是初省值的问题。这三处都改正了。js 这种诡异的异步语法现在才刚刚习惯。

到目前为止，内核到用户再回到内核就没问题了！剩下 hook 没写，所以第二个进程进不去。

在实现 hook 功能和它的按钮之前我先进行一下变量的重命名：

- AddressSpace => BreakpointGroup
- spaces => groups
- KernelHookBreakpoint => HookBreakpoint
- hook_breakpoints => hookBreakpointsFromLaunchJSON
- filePathToSpaceNames => filePathToBreakpointGroupNames
- spaceNameToDebugFilePath => breakpointGroupNameToDebugFilePath
- spaceNameOfBorders => groupNamesOfBorder
- spaceNameOfBorder => groupNameOfBorder
- disableCurrentSpaceBreakpoints => disableCurrentBreakpointGroupBreakpoints
- updateCurrentSpace => updateCurrentBreakpointGroup
- 其他名字里包含'space'，但实际上指断点组的变量

把变量重命名其实不好，因为这会导致涉及旧变量名的文档全部过时。但是这几处修改是非常必要的，所以还是做
了。

既然大代码大改，就顺便把 lint 给解决了一下。

查找资料的时候发现，现在 VSCode 已经可以直接在 extension.ts 里读取配置文件了：

```ts
// launch.json configuration
const config = workspace.getConfiguration("launch", vscode.workspace.workspaceFolders[0].uri);

// retrieve values
const values = config.get("configurations");
```

不过我还是希望大部分配置文件相关的东西都放在 gdb.ts 和 mibase.ts 里，所以只在实现配置文件设置边界断
点时用了一次。要是两年前发现这个 api 就好了，就不需要在 mibase.ts 和 extension.ts 两边传来传去了。两
年前代码看得晕头转向，估计这个 api 给我，我也不知道什么意思。

发现通过上述方式读取的 launch.json 不会自动替换${workspacefolder}变量，我真的吐了，怎么这么恶心阿，
不得不自己实现了变量替换功能。

折腾了一天，终于把边界断点和钩子断点的按钮加回去了，这个没有技术含量，纯苦力活，太累了。

注意 vscode.Location 里面的行号是从 0 开始的，所以调用 new vscode.Location 的时候记得行号 -1 。

尝试了跟踪 getpid() syscall. 发现进到内核之后能成功跟踪回用户态了，但是断点组却在到达用户态之后切到
了内核态的断点组。发现在进内核的时候应该要设置一下 nextbreakpointgroup 的缺省值。因为 getpid()是不会
触发 exec()的，所以不会触发任何钩子，还是回到原来的用户态程序 initproc 上。所以，高级执行环境进入到
低级，比如用户态回内核的时候，要先设置一下“下一个断点组”为原来的那个高级执行环境。在地级执行环境执行
期间如果触发了钩子，那么“下一个断点组”可能会被修改，如果一个钩子都没触发，那就意味着还会回到原来的那
个用户态程序。

```ts
else if(action.type === DebuggerActions.high_level_switch_breakpoint_group_to_low_level){//for example, user to kernel
			const high_level_breakpoint_group_name = this.breakpointGroups.getCurrentBreakpointGroupName();
			this.breakpointGroups.updateCurrentBreakpointGroup(this.breakpointGroups.getNextBreakpointGroup());
			this.breakpointGroups.setNextBreakpointGroup(high_level_breakpoint_group_name);// if a hook is triggered during low level execution, NextBreakpointGroup will be set to the return value of hook behavior function.
		}
```

虽然钩子还没写，但是已经切换了四五次了，只有一次停在没设断点的地方（可能是 GDB 错误地解析了符号表文
件）但是总体是正确的。太好了。

我想先不弄边界，直接在钩子那个地方设断点，看一下用什么 GDB 命令可以一次性把字符串给搞出来，免得像之
前那样先得到地址，再由地址解析出字符串，还得用正则表达式倒来倒去。结果调试 session 直接结束了。后来
发现是这个函数有问题：

```ts
const kernelToUserBorderFile = this.breakpointGroups.getCurrentBreakpointGroup().border.filepath;
const kernelToUserBorderLine = this.breakpointGroups.getCurrentBreakpointGroup().border.line;
```

没设置边界的话`getCurrentBreakpointGroup()`会返回 undefined，然后又去读 undefined 的属性，就会直接退
出。著名的 Cannot read properties of undefined 错误。

我目前不想去做很详细的错误处理，所以先加个问号将就一下，注意问号是加在 border 后面而不是
getCurrentBreakpointGroup()后面。如果加在 getCurrentBreakpointGroup()后面还是会有读 undefined 的属性
的问题：

```ts
const kernelToUserBorderFile = this.breakpointGroups.getCurrentBreakpointGroup().border?.filepath;
const kernelToUserBorderLine = this.breakpointGroups.getCurrentBreakpointGroup().border?.line;
```

然后就成功停在 path 变量出现的那个地方了。这种本地的变量很好获取：

```ts
x /s path.vec.buf.ptr.pointer.pointer
```

因为确实没找到好的对应的 GDB MI Command，干脆就这么暴力获取得了（variablesRequest 的代码看了，其实大
部分都是和编辑器的交互。获取数据的方法本质上也是调用-data-evaluate-expression 加上 MINode.valueOf()
方法。没啥好借鉴的）：

```ts
	public async getStringVariable(name:string):Promise<string>{
		let node = await this.miDebugger.sendCliCommand('x /s '+name+'.vec.buf.ptr.pointer.pointer');
		let resultstring = node.result('value');
		return /"(.*?)"/.exec(resultstring)[0];
	}

```

这回用的正则简单多了，因为 x /s path.vec.buf.ptr.pointer.pointer 返回的值很简单。

出现了怪错误：Activating extension 'chenzhiy2001.debug' failed: Class extends value undefined is not
a constructor or null. 睡觉了 都 1 点 41 了

发现把一个类定义和函数定义从 gdb.ts 移动到 mibase.ts 就可以正常运转了。可能代码里面有“执行 gdb.ts 里
的第一个实体”的代码。本来是类定义和方法定义，我把方法单独拿出来作为函数（因为方法好像不起作用），结
果还是崩溃了，再查一下代码.

发现钩子函数确实不能访问 this。但是之前那个小例子里面却可以。那问题不大，~~改成只使用全局变量即可~~
我要的那些信息都是在类里面的，改成全局会非常麻烦。还有一个办法，就是不用 new Function 改用 eval:
eval 是可以访问上下文的（同时 eval 也会部分阻止编译时的 minification 来保证这一点），但是 eval 会影
响性能，没办法。 eval 可以直接执行语句的，但是我还是希望返回一个函数，再执行那个函数。因为这样只要改
动下面这一个函数就可以了：

```ts
// using eval will stop minification in some scopes, thus increasing the code size in released package.
// but we have to do it since
export function objectAsFunctionToFunction(o: ObjectAsFunction): Function {
	//return new Function(o.functionArguments, o.functionBody);
	return eval(`
		(${o.functionArguments})=>{
			${o.functionBody}
		}
	`);
}
```

但是这样也是不行的，因为这样的话 this 指向的不是 GDBDebugSession。为了保证 this 指向的是
GDBDebugSession（它继承了 MI2DebugSession）就导致我们可能得直接存储 ObjectAsFunction，在需要的时候再
eval，而不能先 eval 了，保存在某个属性里面，等需要的时候再调用函数。这就导致又得修改好几处代码，服了
。

现在 Hookbreakpoint 里面的 behavior 是一个字符串（type FunctionString = string;）必要的时候 eval 然
后再调用。代码写成这样是真的丑，但是没办法。

终于，用户自定义函数可以访问 this.showInformationMessage，并成功输出信息了。

但是我们获取变量信息的函数是异步的：

```ts
for (const hook of this.breakpointGroups.getCurrentBreakpointGroup().hooks) {
	//todo since hook.behavior is async, it is possible that os jump to border before the hook finished, causing nextbreakpointgroup not updated properly.
	//in this extreme case, use `this.currentHook`.
	this.currentHook = hook;
	if (filepath === hook.breakpoint.file && lineNumber === hook.breakpoint.line) {
		eval(hook.behavior)().then((hookResult: string) => {
			this.breakpointGroups.setNextBreakpointGroup(hookResult);
			this.currentHook = undefined;
		});
	}
}
```

**所以存在一种极端情况：内核触发钩子收集下一个用户进程信息，但是信息还没来得及收集完，用户就跳到边界
断点准备步进。这种情况下就有可能步进到错误的断点组中。** 用户自己点 continue 的话不太可能出现这种情
况，但是如果哪一天谁弄了自动 continue 的功能的话就很可能出现这种情况了。所以我弄了一个
this.currentHook 变量，如果当前没有钩子在执行的话它就是 undefined。未来可能会用得上这个变量。

关于怎么恰当地安排这些.then await 的异步机制，我实在搞不懂，出人意料之外的是，chatgpt 的回答正合我意
：

To get the modified value of `p` after calling the function `a()`, you need to ensure that `p` is
accessible outside the function scope. You can achieve this by defining `p` outside of the function
or by returning the modified value from the function. Here's how you can modify the function `a()`
to return the modified value of `p`:

```ts
let a = async () => {
	let p = "/home/oslab/rCore-Tutorial-v3-eBPF/rCore-Tutorial-v3/user/src/bin/";
	let v = await this.getStringVariable("path");
	p = p + v + ".rs";
	return p;
};
```

Now, when you call `a()`, it will return a promise that resolves to the modified value of `p`. You
can use it like this:

```ts
a().then((modifiedValue) => {
	console.log(modifiedValue); // This will log the modified value of p
});
```

Remember, since `this.getStringVariable('path')` seems to be asynchronous, you need to ensure that
`a()` is either `async` or returns a promise to handle the asynchronous operation properly.

刚才给出的

```ts
for (const hook of this.breakpointGroups.getCurrentBreakpointGroup().hooks) {
	//todo since hook.behavior is async, it is possible that os jump to border before the hook finished, causing nextbreakpointgroup not updated properly.
	//in this extreme case, use `this.currentHook`.
	this.currentHook = hook;
	this.showInformationMessage("hook is " + hook.behavior);
	if (filepath === hook.breakpoint.file && lineNumber === hook.breakpoint.line) {
		eval(hook.behavior)().then((hookResult: string) => {
			this.breakpointGroups.setNextBreakpointGroup(hookResult);
			this.currentHook = undefined;
		});
	}
}
```

无需改动，只需要修改 ObjectAsFunction, toFunctionString，添加 isAsync 属性的支持，修改配置文件即可。

然后还是不行，排查了一个下午，晚上弄到 9 点，除了由于异步函数不会用（也不爱用），查资料尝试了半天以
外，另一个问题是 getStringVariable 没有获取到信息。看了一下实际运行时候返回的 MINode，由于我们发送的
是 GDB 命令而不是 GDB/MI 命令，所以会返回 2 个 MINode，其中一个有 token，只有"done"信息，没有这个命
令的处理结果，但是还有另一个 MINode，没有 token，用来表示 GDB 终端输出的内容，这里面有我们想要的。张
露元之前加上了缺失的 token（还添加了一个 api 用于获取这种本来没有 token 的 node。我这里用上了这个
api），加 token 的方式是，每来一个没有 token 的 MINode，就给它 token+1。虽然如果 GDB 返回的 MINode
是乱序的话，加的 token 就和对应的 MINode 的 token 对不上，但是实际运行起来暂时没遇到这个情况。这个潜
在的问题要想解决，唯一的办法就是不使用 GDB 命令，只纯粹使用 GDB/MI 命令。这样的话命令和返回的 MINode
就永远是一对一的。我可以近期改进一下。不一定要创建那些麻烦的 variablescope，只需要用 mi 命令获取字符
串地址和长度，然后直接用获取内存的 mi 命令搞到字符串内容。我这回嫌这个流程太麻烦了，GDB 命令"x /s"简
短好用（x /s 没有对应的 gdb/mi 命令)，才冒险用了 GDB 命令:

```ts
	public async getStringVariable(name:string):Promise<string>{
		const node = await this.miDebugger.sendCliCommand('x /s ' + name + '.vec.buf.ptr.pointer.pointer');
		const resultstring = this.miDebugger.getOriginallyNoTokenMINodes(node.token)[0].outOfBandRecord[0].content;
		this.showInformationMessage("`getStringVariable` got string: " + resultstring);
		return /"(.*?)"/.exec(resultstring)[1];// we want things INSIDE double quotes so it's [1], the first captured group.
	}
```

现在到了可以使用的程度了！内核跟踪到 initproc，再多次回到内核，再回到 user_shell，没有问题。但但是后
面要应对调度等等复杂情况的话，可能需要更多的钩子。不过这就留给后面同学做了。

此外，还做了这些细节改动：

1. 删除不必要的代码
2. 之前发各种 event 都不知道对方是否有收到，很麻烦。因此现在在 mibase.ts 的 customRequest 和
   extension.ts 的 message.event 处理环节添加了报错信息。
3. extension.ts 从现在开始只负责信息展示的工作。对于调试流程的控制全部转移到 mibase.ts 中(但是 eBPF
   的功能还有一些残留在 extension.ts 中，后续会清除)
